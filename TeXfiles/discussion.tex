\chapter{Discussion}
\label{chap:discussion}

\section{Application design decisions}

The initial goal of the thesis was to prove the value of utilizing context information in a task management system. In order to do that, we would need a lot of usage data to support such claims. In the ideal case, and that which was intended at first, we would have plenty of users using the application for a long period of time. Not just that, but the users would also follow the intended workflow of the application, and use it as was intended through the development process. If all of these would have been true, we could have looked at the collected tasks data, and possibly made some conclusions about those data. For example, it might have been possible to look at the average time spent on tasks, and see that this would decrease over time as the app was used more and the recommender learned more of its users behaviors. We could have also been able to conclude about app usage, such as the user becoming better to track their tasks the more time they spent using the application. Of course, the opposite may also be true, that we would have been unable to conclude these things, but the results would still be more valid as the collected amount of data upon which conclusions would have been made would have been much larger.

We could also have used different approaches to try to indicate the usefulness of context information in task management systems. For example, we could have designed a different experiment for testing the application. By using two applications instead of one, we could directly compare the usage and collected data from both of the applications. One application could then be the already created one, as described in this thesis, whereas the other one could be an identical application with the exception of using the recommender and the contexts. We would then be able to compare the two applications directly, provided that the users using the application, are from the same population.

The general application workflow mentioned in Section~\ref{sec:application} might also not have been optimal. Although the choice of making lists and assigning new tasks to lists might be a good idea, our application forces the user to go through a specific list when a task is created. This might not be ideal, as creating a task is something the user does very often. An option to create a new task directly should have been added, so that the user would not have to go through a specific list. When creating a new task independent from a list, the task could default to \emph{today}'s list.

Too much focus was given to usability principles and general design guidelines in the development of the application. These things are necessary to discuss and evaluate, but for a proof of concept application we could have chosen not to implement some of the principles. One example is the swiping between tabs in the main screen of the application. While this is a feature that users are familiar with in such applications, we could have instead created a simple menu for changing between displaying tasks for today, the week, and all tasks. Implementing easy and user friendly swiping led to some problems when it came to updating neighboring tabs. These issues and other similar issues stole some time, which could have been better used for getting more users for the application testing and also having a longer testing period. This way we could have had more conclusive data from the actual usage of the application.



\subsection{Task collection issues and improvements}

The application stores tasks on the users behalf as well as tracking and storing contexts related to those tasks. This is something that would need explicit concent from the user and would also need to be handled properly, in order to avoid violating privacy regulations. We then need to inform the users of the application of what is being collected and stored about the user and his/her tasks as well as why we need to store this information. In our application we have done this through an introductory dialog when the user first starts the application. The user has to accept the written policy in this dialog before he or she can use the application. Though this may be good enough for the purpose of this application, a full scale commercialized application would have to investigate this issue further.

Some considerations have been made towards privacy when storing the application data. On the local device database, the data is stored without obscuring it in any way, as others generally have no access to this data. However, on the remote database, we have applied some sort of anonymization. Here, the individual users are hidden by storing the installation id of the application rather than the users themselves. The contexts however, are not anonymized and could eventually be used to recognize certain users through pattern matching. This could have been handled in this thesis by applying some anonymization over at least the location context data. We would still get the same results as long as identical contexts are anonymized identically.

In a commercialized application there might not be a need for a remote database at all, but it could have some potential uses other than research purposes. For example, when recommending a certain ordering of tasks, one could look at the large pool of data in the remote datastore and calculate the average time spent on certain tasks. This could help the recommender make more informed decisions on the ordering of tasks, especially if the user does not have a large internal task and context history built up yet.



\section{Context collection}
\label{sec:contextcollectiondiscussion}

There was one large problem when collecting context information when the users were doing a task: knowing \emph{when} to collect the context data. For this application, we decided to implement a simple button to start and stop the tracking of contexts when doing a task. Issues regarding this approach were mentioned in Section~\ref{sec:contextcollection}. The ideal way to collect context would be for the user to not having to think about the collection of such data. The application would instead have an autonomous approach of handling this. Of course, such autonomy would be difficult to develop, and also reach outside of the scope of this thesis. However, one way that this could have been done is to let the application collect contexts all the time. The collected contexts would then be assigned to a task when the user finishes a task. Upon the user finishing a task, the application could look back in time a certain time interval and then determine that the contexts collected in that timeframe is the contexts related to the finished task. This approached is also somewhat flawed, as it assumes that the user tells the application that he/she has finished a task, i.e. ``ticks off'' the task, at the actual time the the user finishes it. In reality, many users would sometimes do this at a later point in time, meaning that the contexts assigned to a particular task could be the wrong ones. This error could be reduced over time however, as the application could ``learn'' the typical contexts related to individual tasks.

Another way to solve the problem could be to have the application ask the user to provide the timeframe in which he/she actually did the task when the user ``ticks off'' the task. This way we could assign the correct contexts to the correct tasks. The problem with this approach is usability. The users would not appreciate having to input times whenever they finish tasks. Unnecessary and repetitive operations should be avoided. This option would therefore not be suitable in a commercialized application, but could potentially be used for experimenting purposes.

As the application's user testing for this thesis only lasted for a little more than two weeks, we did not implement any restrictions to prevent old context data from being used. It is possible that, over time, some context information may eventually be outdated. Location contexts for example, could change dramatically if a user moves to a new home or apartment. The location contexts related to the previous place of residence is then no longer relevant. A mechanism for preventing such scenarios should be present in the application. For example, we could limit the task and context history to a month, meaning that tasks and contexts that are older than this will not be used. This way, the application could ``relearn'' new contexts over time.

There is also a limitation to how we stored the activity contexts for the tasks. By storing a particular activity only once, we prevent information overhead, but we also deny ourselves the ability to see the duration of activities when the user is doing a task. If we collect all activities regardless of whether or not an activity has been collected for a particular task earlier, we can see the approximate duration of the individual activities. This could be useful for research purposes.



\section{Recommender and context usage}

As a way to test the usefulness of contexts in a to-do list, we designed a recommender to utilize the collected context and task history. In this thesis, the recommender was somewhat simple and provided recommendations based on only the criteria mentioned in Section~\ref{sec:recommender}. Even though this way of making recommendations can be good in many cases, the recommender could be further improved by implementing more rules. These rules could be general, or task specific. An example of a task specific rule could be that the recommender assumes a task of category \emph{meeting} to be ended if the location suddenly changes by a lot after the meeting has been already started. A more general rule could be the assumption that a task is finished if the activity changes into \emph{in vehicle} and location updates starts coming in frequently. The user is then driving a car, and it is unlikely that he/she is actively performing a planned task.

More rules the the ones mentioned above could be implemented. However, it is more likely that the rules that would be feasible in a commercialized application is the general ones. This is because some of the predefined tasks are very specific for the user group in this thesis work, and would change if tasks were to be generalized.

Another thing that also should have been taken into account is the importance of the different contexts. When making a task recommendation based on contexts, some contexts may be more important than others. To make the recommender account for this, we could have added weights to the different contexts. For example, time contexts may be more relevant than location contexts for certain tasks. We could then write this into our recommendation algorithm. If one task was given a probability based on time context and another task was given the same probability based on location context, the recommender would choose the task whose context is more highly weighted. This is of course more complicated than only comparing equal probabilities. Mathematical expressions would have to be made that allow the comparison of task probabilities directly. 

Instead of actually recommending an ordering of tasks with a most recommended task on top, the recommender could instead \emph{not} recommend tasks. By that we mean that the recommender could look at all previous tasks with their related contexts, as before, and decide which tasks are \emph{not} suitable given the current context of the user. For example, if a user always does one particular task at one specific location, this task can then be ignored if the user is at a different location. This way, the recommender is recommending tasks through a process of ruling out other tasks. A set of tasks that \emph{are} relevant to the current context is then presented to the user. This way of recommending tasks may be especially useful if the user has a very long list of tasks that needs to be done.



\section{Generalization of tasks}
Too reach a wider range of users, it is possible to generalize the types of tasks available to the users. The task \emph{attend lecture} for example, is highly relevant to a student, whereas to more general users it is highly irrelevant. However, generalizing tasks to a large extent could lead to other difficulties. We could make a very general category \emph{work} that applies to most users, but as tasks within this category can differ greatly both in terms of what needs to be done as well as timespan, it will be very difficult for a recommender to compare tasks of this category, and thereby make reasonable recommendations to the user.

One approach that would help solve this, is that instead of trying to generalize tasks too much, we could expand the number of task categories greatly. The more specific a task category can be, the easier it is for the recommender to make  good recommendations for the user. So instead of having a small set of general tasks, we could have a large library of predefined task categories, which could be divided into category sets. For example, the application could let the user select his occupation, and would thereby load a set of predefined task categories that matches the chosen occupation. This would require a lot of work however, as different occupations and their typical tasks would need to be matched together.


- Experiment desig flaws, not able to identify students or find the ones who answered what in the first questionnaire.